import os
import logging
import requests
from typing import Optional
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CommandHandler, CallbackQueryHandler, ContextTypes
from telethon import TelegramClient
from telethon.sessions import StringSession
from LLM import get_available_models, handle_llm_command
# from proposals_editor import propose, set_field, on_callback

# Configure logging
logging.basicConfig(
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s", level=logging.INFO
)
logger = logging.getLogger(__name__)

# Bot token
TOKEN = os.environ.get("TELEGRAM_BOT_TOKEN", "")

# Telethon client configuration (for accessing full chat history)
# These need to be set as environment variables
API_ID = int(os.environ.get("TELEGRAM_API_ID", "0"))
API_HASH = os.environ.get("TELEGRAM_API_HASH", "")
SESSION_STRING = os.environ.get("TELEGRAM_SESSION_STRING", "")

# Jira Auth Server configuration
JIRA_AUTH_SERVER_URL = os.environ.get("JIRA_AUTH_SERVER_URL", "http://localhost:5000")

# LLM API calls are now handled in LLM package

# Initialize Telethon client
client = None

# Function to create a fresh Telethon client
async def create_telethon_client():
    global client
    # Create a new client with the session string
    client = TelegramClient(StringSession(SESSION_STRING), API_ID, API_HASH)
    
    # Start the client with the bot token
    await client.start(bot_token=TOKEN)
    logger.info("Telethon client started successfully")
    return client

# Jira Authorization functions
def is_user_authenticated(telegram_user_id: str) -> bool:
    """–ü—Ä–æ–≤–µ—Ä–∏—Ç—å, –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –≤ Jira"""
    try:
        response = requests.get(f"{JIRA_AUTH_SERVER_URL}/auth/status/{telegram_user_id}")
        return response.json().get('authenticated', False)
    except Exception as e:
        logger.error(f"Error checking auth status: {e}")
        return False

def get_user_jira_token(telegram_user_id: str) -> Optional[str]:
    """–ü–æ–ª—É—á–∏—Ç—å —Ç–æ–∫–µ–Ω –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –¥–ª—è Jira API"""
    try:
        response = requests.get(f"{JIRA_AUTH_SERVER_URL}/auth/status/{telegram_user_id}")
        if response.json().get('authenticated', False):
            # –ó–¥–µ—Å—å –Ω—É–∂–Ω–æ –±—É–¥–µ—Ç –¥–æ–±–∞–≤–∏—Ç—å –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏–π API –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Ç–æ–∫–µ–Ω–∞
            # –ü–æ–∫–∞ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –∑–∞–≥–ª—É—à–∫—É
            return "authenticated_user_token"
    except Exception as e:
        logger.error(f"Error getting user token: {e}")
    return None

# Get last 50 chat messages using Telethon
async def get_chat_messages(update: Update, context: ContextTypes.DEFAULT_TYPE) -> str:
    global client
    
    if client is None or not client.is_connected():
        logger.error("Telethon client is not connected")
        return "Error: Could not connect to Telegram to retrieve messages."
    
    chat_id = update.effective_chat.id
    
    # Get last 50 messages using Telethon
    messages = []
    try:
        logger.info("Getting last 50 messages from chat")
        message_count = 0
        async for message in client.iter_messages(chat_id, limit=50):
            # Skip bot's own messages
            if message.from_id and hasattr(message.from_id, 'user_id') and message.from_id.user_id == context.bot.id:
                continue
                
            # Add message to our collection if it has text
            if message.text:
                sender = None
                if message.sender:
                    sender = message.sender.username or message.sender.first_name
                else:
                    sender = "Unknown"
                messages.append(f"{sender}: {message.text}")
                message_count += 1
        
        logger.info(f"Retrieved {message_count} messages from chat history")
        
        # Join messages into a single string
        return "\n".join(messages) if messages else "No messages found in chat."
    except Exception as e:
        logger.error(f"Error retrieving messages: {e}")
        return f"Error retrieving messages: {str(e)}"

# Command handler for /auth command
async def auth_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """–ö–æ–º–∞–Ω–¥–∞ –¥–ª—è –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤ Jira"""
    user_id = update.effective_user.id
    user_name = update.effective_user.first_name
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω –ª–∏ —É–∂–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å
    if is_user_authenticated(user_id):
        await update.message.reply_text(
            f"‚úÖ {user_name}, –≤—ã —É–∂–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω—ã –≤ Jira!\n"
            f"–ú–æ–∂–µ—Ç–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∫–æ–º–∞–Ω–¥—ã –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –∑–∞–¥–∞—á–∞–º–∏."
        )
        return
    
    try:
        # –ü–æ–ª—É—á–∞–µ–º —Å—Å—ã–ª–∫—É –¥–ª—è –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏ –æ—Ç —Å–µ—Ä–≤–µ—Ä–∞
        response = requests.get(f"{JIRA_AUTH_SERVER_URL}/auth/start?telegram_user_id={user_id}")
        
        if response.status_code == 200:
            auth_data = response.json()
            auth_url = auth_data.get('auth_url')
            
            if auth_url:
                keyboard = [
                    [InlineKeyboardButton("üîê –ê–≤—Ç–æ—Ä–∏–∑–æ–≤–∞—Ç—å—Å—è –≤ Jira", url=auth_url)]
                ]
                reply_markup = InlineKeyboardMarkup(keyboard)
                
                await update.message.reply_text(
                    f"üëã {user_name}, –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å Jira –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞—Ç—å—Å—è.\n\n"
                    f"–ù–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É –Ω–∏–∂–µ, —á—Ç–æ–±—ã –ø–µ—Ä–µ–π—Ç–∏ –∫ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏:",
                    reply_markup=reply_markup
                )
            else:
                await update.message.reply_text(
                    f"‚ùå {user_name}, –Ω–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Å—Å—ã–ª–∫—É –¥–ª—è –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏.\n"
                    f"–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ –∏–ª–∏ –æ–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É."
                )
        else:
            await update.message.reply_text(
                f"‚ùå {user_name}, —Å–µ—Ä–≤–µ—Ä –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω.\n"
                f"–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ –∏–ª–∏ –æ–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É."
            )
            
    except Exception as e:
        logger.error(f"Error getting auth URL: {e}")
        await update.message.reply_text(
            f"‚ùå {user_name}, –ø—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Å—Å—ã–ª–∫–∏ –¥–ª—è –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏.\n"
            f"–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ –∏–ª–∏ –æ–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É."
        )

# Command handler for /status command
async def status_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """–ö–æ–º–∞–Ω–¥–∞ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —Å—Ç–∞—Ç—É—Å–∞ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏"""
    user_id = update.effective_user.id
    user_name = update.effective_user.first_name
    
    if is_user_authenticated(user_id):
        await update.message.reply_text(
            f"‚úÖ {user_name}, –≤—ã –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω—ã –≤ Jira!\n"
            f"–ú–æ–∂–µ—Ç–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –≤—Å–µ —Ñ—É–Ω–∫—Ü–∏–∏ –±–æ—Ç–∞."
        )
    else:
        await update.message.reply_text(
            f"‚ùå {user_name}, –≤—ã –Ω–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω—ã –≤ Jira.\n"
            f"–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–º–∞–Ω–¥—É /auth –¥–ª—è –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏."
        )

# Command handler for /brief command with auth check
async def brief_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """–ö–æ–º–∞–Ω–¥–∞ –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞ —á–∞—Ç–∞ —Å –ø—Ä–æ–≤–µ—Ä–∫–æ–π –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏"""
    user_id = update.effective_user.id
    user_name = update.effective_user.first_name
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—é
    if not is_user_authenticated(user_id):
        await update.message.reply_text(
            f"‚ùå {user_name}, –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è —ç—Ç–æ–π —Ñ—É–Ω–∫—Ü–∏–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞—Ç—å—Å—è –≤ Jira.\n"
            f"–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–º–∞–Ω–¥—É /auth –¥–ª—è –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏."
        )
        return
    
    # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –¥–æ—Å—Ç—É–ø–Ω—ã–µ –º–æ–¥–µ–ª–∏
    available_models = get_available_models()
    
    # Create keyboard buttons dynamically
    keyboard = []
    for model_id, display_name in available_models.items():
        keyboard.append([InlineKeyboardButton(display_name, callback_data=model_id)])
    
    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text("–í—ã–±–µ—Ä–∏—Ç–µ –º–æ–¥–µ–ª—å LLM:", reply_markup=reply_markup)

async def test_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    # Log user ID who called the bot
    user_id = update.effective_user.id
    user_name = update.effective_user.first_name
    logger.info(f"Test command called by user ID: {user_id}, Name: {user_name}")
    
    # Check authentication
    if not is_user_authenticated(user_id):
        await update.message.reply_text(
            f"‚ùå {user_name}, –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è —ç—Ç–æ–π —Ñ—É–Ω–∫—Ü–∏–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞—Ç—å—Å—è –≤ Jira.\n"
            f"–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–º–∞–Ω–¥—É /auth –¥–ª—è –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏."
        )
        return
    
    test_file_name = "sample_chat_dialogue_workplace.txt"
    test_chat_history = ""
    if os.path.exists(test_file_name):
        with open(test_file_name, "r", encoding="utf-8") as f:
            test_chat_history = f.read().strip()
    await update.message.reply_text("Processing messages using OpenAI...")
    response, success = await handle_llm_command(test_chat_history, 'model_openai', str(user_id))
    
    # Send response and store the message ID if successful
    await update.message.reply_text(response)

# Callback handler for model selection with auth check
async def brief_callback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Callback –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –≤—ã–±–æ—Ä–∞ –º–æ–¥–µ–ª–∏ —Å –ø—Ä–æ–≤–µ—Ä–∫–æ–π –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏"""
    query = update.callback_query
    await query.answer()
    
    user_id = update.effective_user.id
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—é
    if not is_user_authenticated(user_id):
        await query.edit_message_text(
            "‚ùå –î–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è —ç—Ç–æ–π —Ñ—É–Ω–∫—Ü–∏–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞—Ç—å—Å—è –≤ Jira.\n"
            "–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–º–∞–Ω–¥—É /auth –¥–ª—è –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏."
        )
        return
    
    model = query.data
    await query.edit_message_text(f"–û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏–π —Å –ø–æ–º–æ—â—å—é {model}...")
    
    # –ü–æ–ª—É—á–∞–µ–º —Å–æ–æ–±—â–µ–Ω–∏—è —á–∞—Ç–∞
    await query.edit_message_text("–ü–æ–ª—É—á–µ–Ω–∏–µ —Å–æ–æ–±—â–µ–Ω–∏–π —á–∞—Ç–∞...")
    messages = await get_chat_messages(update, context)
    
    if messages == "No messages found in chat.":
        await query.edit_message_text("–°–æ–æ–±—â–µ–Ω–∏—è –≤ —á–∞—Ç–µ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã.")
        return
    
    # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Å–æ–æ–±—â–µ–Ω–∏—è —Å –ø–æ–º–æ—â—å—é LLM
    response, success = await handle_llm_command(messages, model, str(user_id))
    
    # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –æ—Ç–≤–µ—Ç
    await query.edit_message_text(response)

# Main function
async def main() -> None:
    try:
        # Create and start Telethon client first (only once)
        logger.info("Creating and starting Telethon client...")
        await create_telethon_client()
        
        # Create application
        application = Application.builder().token(TOKEN).build()
        
        # Add handlers
        application.add_handler(CommandHandler("auth", auth_command))
        application.add_handler(CommandHandler("status", status_command))
        application.add_handler(CommandHandler("brief", brief_command))
        application.add_handler(CommandHandler("test", test_command))
 #       application.add_handler(CommandHandler("propose", propose))
 #       application.add_handler(CommandHandler("set", set_field))
        application.add_handler(CallbackQueryHandler(brief_callback, pattern="^model_"))
 #       application.add_handler(CallbackQueryHandler(on_callback, pattern="^(?!model_).+"))
        
        # Run the bot with updater
        logger.info("Starting Telegram bot application...")
        await application.initialize()
        await application.start()
        
        # Keep the application running
        await application.updater.start_polling()
        
        # Use a simple loop to keep the application running
        logger.info("Bot is running. Press Ctrl+C to stop.")
        while True:
            await asyncio.sleep(1)
    except Exception as e:
        logger.error(f"Error in main function: {e}")
        raise
    finally:
        # Properly close the client when the bot stops
        logger.info("Shutting down...")
        if client and client.is_connected():
            await client.disconnect()
        await application.stop()

if __name__ == "__main__":
    import asyncio
    asyncio.run(main())
